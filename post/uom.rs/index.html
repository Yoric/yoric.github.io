<!DOCTYPE html>
<html class="js no-touch  progressive-image  no-reduced-motion progressive" lang="en">
  <head>
    <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="icon" href="https://yoric.github.io/img/favicon.ico">

    <meta name="keyword" content=""><meta property="og:url" content="https://yoric.github.io/post/uom.rs/">
  <meta property="og:site_name" content="Il y a du thé renversé au bord de la table !">
  <meta property="og:title" content="Units of Measure in Rust with Refinement Types">
  <meta property="og:description" content="Years ago, Andrew Kennedy published a foundational paper about a type checker for units of measure, and later implemented it for F#. To this day, F# is the only mainstream programming language which provides first class support to make sure that you will not accidentally confuse meters and feet, euros and dollars, but that you can still convert between watts·hours and joules.
I decided to see whether this could be implemented in and for Rust. The answer is not only yes, but it was fun :)">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2020-01-17T13:35:02+01:00">
    <meta property="article:modified_time" content="2020-01-17T13:35:02+01:00">
    <meta property="article:tag" content="Mozilla">
    <meta property="article:tag" content="Rust">
    <meta property="article:tag" content="Types">
<title>Units of Measure in Rust with Refinement Types</title>

    <link rel="canonical" href="https://yoric.github.io/post/uom.rs/">

    <link rel="stylesheet" href="https://yoric.github.io/css/global.css">

    <link rel="stylesheet" href="https://yoric.github.io/css/custom.css">

    <link rel="stylesheet" href="https://yoric.github.io/css/search.css" />

    
    

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    

    
    

</head>
  </head>
  <body class=" page-article   ">
    <header>
      <nav class="nav">
  <div class="nav-wrapper">
    <div class="nav-content-wrapper">
      <div class="nav-content">
        <a href="https://yoric.github.io/ " class="nav-title">Il y a du thé renversé au bord de la table !</a>
        <div class="nav-menu">
          <div class="nav-item-wrapper">
            <a href="https://yoric.github.io/post " class="nav-item-content">Articles</a>
          </div><div class="nav-item-wrapper">
            <a href="https://yoric.github.io/about" class="nav-item-content">About</a>
          </div><div class="nav-item-wrapper">
            <a href="https://yoric.github.io/index.xml" class="nav-item-content" target="_blank">RSS</a>
          </div></div>
      </div>
    </div>
  </div>
</nav>

<script>
  function toggleSearchModal(){
    const template = `
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `
    const modal = document.querySelector("#modal-wrapper")
    if(!modal){
      const div = document.createElement("div")
      document.body.setAttribute("style","overflow: hidden;")
      div.setAttribute("id", "modal-wrapper")
      div.setAttribute("onclick", "toggleSearchModal()")
      div.innerHTML = template
      const script = document.createElement("script");script.setAttribute("src", "https://yoric.github.io/js/algolia.js")
      div.appendChild(script)
      document.body.append(div)
    } else {
      document.body.removeAttribute("style")
      document.body.removeChild(modal)
    }
  }
</script>
    </header>
    
  
  
  <main id="main" class="main">
      <section>
        <article class="article">
          
          <div class=" article-header ">
            <div class="category component">
              <div class="component-content">
                <div class="category-eyebrow">
                  <span class="category-eyebrow__category category_original">
                    
                      
                        Mozilla
                      
                    
                  </span>
                  <span class="category-eyebrow__date">January 17, 2020</span>
                </div>
              </div>
            </div>
            <div class="pagetitle component">
              <div class="component-content">
                <h1 class="hero-headline">Units of Measure in Rust with Refinement Types</h1>
              </div>
            </div>
            <div class="component  article-subhead ">
              <div class="component-content"></div>
            </div>

            <div class="tagssheet component">
              <div class="component-content">
                
                  
                  <a href="https://yoric.github.io/tags/mozilla" class="tag">
                    Mozilla
                  </a>
                
                  
                  <a href="https://yoric.github.io/tags/rust" class="tag">
                    Rust
                  </a>
                
                  
                  <a href="https://yoric.github.io/tags/types" class="tag">
                    types
                  </a>
                
              </div>
            </div>
          </div>
          
          <div class="pagebody">
            
            
            
            
            
            
            
            
            <p class="component-content component">Years ago, Andrew Kennedy published <a href="http://typesatwork.imm.dtu.dk/material/TaW_Paper_TypesAtWork_Kennedy.pdf">a foundational paper</a> about a type checker for units of measure, and later <a href="https://docs.microsoft.com/en-us/archive/blogs/andrewkennedy/units-of-measure-in-f-part-one-introducing-units">implemented it for
F#</a>. To this day, F# is the only mainstream programming language which provides first class support to make sure that you will not accidentally confuse meters and feet, euros and dollars, but that you can still convert between watts·hours and joules.</p>
<p class="component-content component">I decided to see whether this could be implemented in and for Rust. The answer is not only yes, but it was fun :)</p>

<div class="component-content pagebody component">
  <h1 id="units-of-measure-as-newtypes" class="pagebody-header">
    Units of Measure as newtypes
  </h1>
</div><p class="component-content component">Units of Measure are, well, labels attacked to things that you can measure: <em>seconds</em>, <em>hours</em>, <em>miles per hour</em>, <em>dollars per galleon</em>, <em>watts multipled per hours</em>, etc. A speed (that&rsquo;s a measure) can be in <em>miles per hours</em>, <em>kilometers per hours</em>, <em>multiples of lightspeed</em> (that&rsquo;s units).</p>
<p class="component-content component">If you confuse your units, you can get a disaster – setting the temperature of your personal oven ors heater in Celcius instead of Fahrenheit is clumsy, and in an industrial setting, this can kill people. With similar errors, <a href="https://spacemath.gsfc.nasa.gov/weekly/6Page53.pdf">NASA lost a Mars Orbiter</a>.</p>
<p class="component-content component">In Rust, the classical way to ensure that you do not confuse these measures is to <em>newtype</em> each measure:</p>
<div class="component-content pagebody component code">
  
  
  
  <div class=""><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> derive_more;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// A measure in kilometers.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// - #[derive(Add)] because such numbers can be added to each other.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// - #[derive(Sub)] because such numbers can be subtracted from each other.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// - #[derive(Default)] as zero value.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// - do NOT #[derive(Mul)] or #[derive(Div)] because a kilometer multiplied by a kilometer is a square kilometer, not a kilometer.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">#[derive(Add, Sub, Default)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Km</span>(<span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// A kilometer divided by a kilometer is a number without unit.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">impl</span> Div <span style="color:#66d9ef">for</span> Km {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">div</span>(self, other: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#66d9ef">f64</span> {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">0</span> <span style="color:#f92672">/</span> other.<span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// A measure in seconds.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">#[derive(Add, Sub, Default)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span>(<span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// A second divided by a second is a number without unit.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">impl</span> Div <span style="color:#66d9ef">for</span> S {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">div</span>(self, other: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#66d9ef">f64</span> {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">0</span> <span style="color:#f92672">/</span> other.<span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> distance <span style="color:#f92672">=</span> Km(<span style="color:#ae81ff">300_000.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> duration <span style="color:#f92672">=</span> S(<span style="color:#ae81ff">1.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> delta <span style="color:#f92672">=</span> distance <span style="color:#f92672">-</span> duration; <span style="color:#75715e">// ERROR: Doesn&#39;t type-check.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div></div>
  
</div><p class="component-content component">That&rsquo;s good and it works well.</p>
<p class="component-content component">What if we want to add speed?</p>
<div class="component-content pagebody component code">
  
  
  
  <div class=""><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> derive_more;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> Skip the above.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// A speed in km·s^-1 (aka kilometers per seconds).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">#[derive(Add, Sub, Default)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">KmPerS</span>(<span style="color:#66d9ef">f64</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// A value divided by a value of the same unit is a number without unit.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">impl</span> Div <span style="color:#66d9ef">for</span> KmPerS {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">div</span>(self, other: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#66d9ef">f64</span> {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">0</span> <span style="color:#f92672">/</span> other.<span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Implement Km / S =&gt; KmPerS
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">impl</span> Div<span style="color:#f92672">&lt;</span>S<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> Km {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> KmPerS;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">div</span>(self, rhs: <span style="color:#a6e22e">S</span>) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        KmPerS(self.<span style="color:#ae81ff">0</span> <span style="color:#f92672">/</span> rhs.<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Implement KmPerS * S =&gt; Km
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">impl</span> Mul<span style="color:#f92672">&lt;</span>S<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> KmPerS {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Km;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">div</span>(self, rhs: <span style="color:#a6e22e">S</span>) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        Km(self.<span style="color:#ae81ff">0</span> <span style="color:#f92672">*</span> rhs.<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Also implement S * KmPerS =&gt; Km
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">impl</span> Mul<span style="color:#f92672">&lt;</span>KmPerS<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> S {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Km;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">div</span>(self, rhs: <span style="color:#a6e22e">S</span>) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        Km(self.<span style="color:#ae81ff">0</span> <span style="color:#f92672">*</span> rhs.<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> distance <span style="color:#f92672">=</span> Km(<span style="color:#ae81ff">300_000.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> duration <span style="color:#f92672">=</span> S(<span style="color:#ae81ff">1.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> speed <span style="color:#f92672">=</span> distance <span style="color:#f92672">/</span> duration;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> distance_2 <span style="color:#f92672">=</span> speed <span style="color:#f92672">*</span> duration;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> distance <span style="color:#f92672">-</span> distance_2; <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> distance_3 <span style="color:#f92672">=</span> duration <span style="color:#f92672">*</span> speed;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> distance <span style="color:#f92672">-</span> distance_3;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
  
</div><p class="component-content component">Ok, that works, too. It&rsquo;s starting to be verbose but it works.</p>
<p class="component-content component">But what if we wish to add acceleration in kilometers per second squared? Well, we need to:</p>
<div class="component-content component"><ul>
<li>create another <code>struct KmPerSSquared</code>;</li>
<li>derive addition, multiplication, zero;</li>
<li>implement <code>Div&lt;KmPerSSquared&gt; for KmPerSSquared</code>;</li>
<li>implement <code>Div&lt;S&gt; for KmPerS</code>;</li>
<li>implement <code>Mul&lt;S&gt; for KmPerSSquared</code>.</li>
</ul></div>
<p class="component-content component">Oh, wait, there is another way to obtain a kilometer per second squared. It&rsquo;s to divide kilometers per (second squared). So we may need to implement seconds squared, with all their operations. Of course, seconds squared divided by seconds should also be seconds, seconds multiplied by seconds should be second squared, &hellip;</p>
<p class="component-content component">That&rsquo;s yet another structure with its derived addition, multiplication, zero, four more implementations, etc.</p>
<p class="component-content component">Hopefully, by now, I have convinced you that this technique doesn&rsquo;t scale!</p>

<div class="component-content pagebody component">
  <h1 id="units-of-measure-generalized" class="pagebody-header">
    Units of Measure, generalized
  </h1>
</div><p class="component-content component">Now that we have seen that the manual method works but doesn&rsquo;t scale, let&rsquo;s see if something more generic would do the trick.</p>
<div class="component-content pagebody component code">
  
  
  
  <div class=""><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">crate</span> yaiouom;<span style="color:#75715e">// Yet Another Implementation Of Units Of measure.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> yaiouom::Measure;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Kilometers. This type has nothing special.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Km</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Seconds. This type has also nothing special.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Define our distance and duration, once again.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Note that the `f64` is optional. Rust will infer it nicely.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> distance <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, Km<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">300_000.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> duration <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, S<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">1.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// let error = distance + duration;  // ERROR: Caught by type-checking.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> speed <span style="color:#f92672">=</span> distance <span style="color:#f92672">/</span> duration;     <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> acceleration <span style="color:#f92672">=</span> speed <span style="color:#f92672">/</span> duration; <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div></div>
  
</div><p class="component-content component">The type of <code>speed</code> is <code>Measure::&lt;f64, yaiouom::Div&lt;Km, S&gt;&gt;</code> – aka &ldquo;<code>speed</code> is a <code>f64</code> measure in <code>Km/S</code>&rdquo;.
Similarly, the type of <code>acceleration</code> is <code>Measure::&lt;f64, yaiouom::Div&lt;uom::Div&lt;Km, S&gt;&gt; , S&gt;</code> – aka &ldquo;<code>acceleration</code>&rdquo; is a <code>f64</code> measure in <code>Km/S/S</code>, all nicely infered.</p>
<p class="component-content component">Well, that&rsquo;s already a nice improvement!</p>
<p class="component-content component">Unfortunately, this approach also quickly runs into its own limitations:</p>
<div class="component-content pagebody component code">
  
  
  
  <div class=""><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> distance <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, Km<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">300_000.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> duration <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, S<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">1.</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> speed <span style="color:#f92672">=</span> distance <span style="color:#f92672">/</span> duration;     <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> acceleration <span style="color:#f92672">=</span> speed <span style="color:#f92672">/</span> duration; <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> acceleration_2 <span style="color:#f92672">=</span> distance <span style="color:#f92672">/</span> (duration <span style="color:#f92672">*</span> duration); <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    assert_eq!(acceleration, acceleration_2); <span style="color:#75715e">// ERROR: Type-checking fails.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div></div>
  
</div><p class="component-content component">What has happened here? Well, <code>acceleration</code> is a measure in <code>(Km/S)/S</code>, while <code>acceleration_2</code> is a measure in <code>Km/(S*S)</code>. In terms of units of measure, these are exactly the same things, but the type system doesn&rsquo;t know about it.</p>
<p class="component-content component">In fact, what&rsquo;s missing here is a set of type-level <em>equational</em> laws. If we call <code>Unitless</code> the pseudo-unit of unitless values
and if we rewrite <code>A/B</code> as <code>A*B^-1</code>, we just to define <code>≡</code> as the smallest equivalence relation such that</p>
<div class="component-content component"><ul>
<li>for all units <code>A</code>, <code>B</code>, <code>A*B ≡ B*A</code> (Commutativity)</li>
<li>for all unit <code>A</code>, <code>A*A^-1 ≡ Unitless</code> (Inverse)</li>
<li>for all unit <code>A</code> <code>A * Unitless ≡ A</code> (Neutral element)</li>
<li>for all units <code>A</code>, <code>B</code>, <code>C</code>, <code>A*(B*C) ≡ (A*B)*C</code> (Associativity)</li>
<li>for all units <code>A</code>, <code>B</code>, <code>C</code>, if <code>A ≡ B</code> then <code>A*C ≡ B*C</code> (Congruence of Multiplicatives)</li>
<li>for all units <code>A</code>, <code>B</code>, if <code>A ≡ B</code> then <code>A^-1 ≡ B^-1</code> (Congruence of Inverses)</li>
</ul></div>
<p class="component-content component">Is this sufficient? Well, for the case of <code>acceleration</code> and <code>acceleration_2</code>, we only need Associativity:</p>
<div class="component-content component"><ol>
<li>Proving that <code>(Km/S)/S ≡ Km/(S*S)</code> is the same thing as proving that <code>(Km * S^-1) * S^1 ≡ Km * (S^-1 * S^-1)</code> (we&rsquo;re just changing notations).</li>
<li>Thanks to Associativity, we know that <code>(Km * S^-1) * S^1 ≡ Km * (S^-1 * S^-1)</code>.</li>
<li>So, we have a proof, our code is safe (for some reasonable definition of safe)!</li>
</ol></div>
<p class="component-content component">Well, that&rsquo;s all nice and dandy, but how do we teach this to the Rust compiler?</p>
<p class="component-content component">We&rsquo;re going to introduce a <em>refinement type</em>.</p>
<p class="component-content component">Before giving more details, let me show you the final result:</p>
<div class="component-content pagebody component code">
  
  
  
  <div class=""><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> distance <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, Km<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">300_000.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> duration <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, S<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">1.</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> speed <span style="color:#f92672">=</span> distance <span style="color:#f92672">/</span> duration;     <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> acceleration <span style="color:#f92672">=</span> speed <span style="color:#f92672">/</span> duration; <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> acceleration_2 <span style="color:#f92672">=</span> (distance <span style="color:#f92672">/</span> (duration <span style="color:#f92672">*</span> duration)).unify(); <span style="color:#75715e">// &lt;-- This line has changed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    assert_eq!(acceleration, acceleration_2); <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div></div>
  
</div><p class="component-content component">Ohhh&hellip; a mysterious method <code>unify()</code> that magically solves our issue. Let&rsquo;s look at its source code:</p>
<div class="component-content pagebody component code">
  
  
  
  <div class=""><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> Measure {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unify</span><span style="color:#f92672">&lt;</span>V<span style="color:#f92672">&gt;</span>(self) -&gt; <span style="color:#a6e22e">Measure</span><span style="color:#f92672">&lt;</span>T, V<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Measure::new(self.<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
  
</div><p class="component-content component">This method is&hellip; simply <em>discarding</em> the unit of measure. Surely, that can&rsquo;t be safe (for some reasonable definition of safety)?</p>
<p class="component-content component">Let&rsquo;s confirm this:</p>
<div class="component-content pagebody component code">
  
  
  
  <div class=""><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> distance <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, Km<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">300_000.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> duration <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, S<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">1.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> distance.unify() <span style="color:#f92672">-</span> duration; <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div></div>
  
</div><p class="component-content component">Indeed, we have just managed to subtract a duration from a distance, that&rsquo;s clearly worthless.</p>
<p class="component-content component">Let&rsquo;s see how we can make it safe!</p>

<div class="component-content pagebody component">
  <h1 id="a-refinement-type-system-for-units-of-measure" class="pagebody-header">
    A refinement type-system for Units of Measure
  </h1>
</div><p class="component-content component">The Rust toolchain has many tricks up its sleeves. One of them is the ability to use the compiler as a library and build static analysis tools on top of it.</p>
<p class="component-content component">Now, instead of <code>rustc</code>, let&rsquo;s run <code>yaiouom-checker</code>.</p>
<p class="component-content component">First with our good sample:</p>
<div class="component-content pagebody component code">
  
  
  
  <div class=""><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> distance <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, Km<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">300_000.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> duration <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, S<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">1.</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> speed <span style="color:#f92672">=</span> distance <span style="color:#f92672">/</span> duration;     <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> acceleration <span style="color:#f92672">=</span> speed <span style="color:#f92672">/</span> duration; <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> acceleration_2 <span style="color:#f92672">=</span> (distance <span style="color:#f92672">/</span> (duration <span style="color:#f92672">*</span> duration)).unify();
</span></span><span style="display:flex;"><span>    assert_eq!(acceleration, acceleration_2); <span style="color:#75715e">// PASS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div></div>
  
</div><p class="component-content component">ok, the good sample still passes. So far, so good.</p>
<p class="component-content component">Now with the bad sample:</p>
<div class="component-content pagebody component code">
  
  
  
  <div class=""><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> distance <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, Km<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">300_000.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> duration <span style="color:#f92672">=</span> Measure::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, S<span style="color:#f92672">&gt;</span>::new(<span style="color:#ae81ff">1.</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> distance.unify() <span style="color:#f92672">-</span> duration; <span style="color:#75715e">// ERROR: Doesn&#39;t type check anymore!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Error:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//         ----------------- in this unification
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    = note: expected unit of measure: `S`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//               found unit of measure: `Km`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div></div>
  
</div><p class="component-content component">&hellip;and the error was caught!</p>
<p class="component-content component">Let&rsquo;s look at the steps involved in a run of <code>yaiouom-checker</code>:</p>
<div class="component-content component"><ol>
<li>run the usual <code>rustc</code> type and region inference;</li>
<li>using the result of type inference, determine all the callsites of our method <code>unify</code>;</li>
<li>using the result of type inference, at each of these callsites</li>
<li>determine the type of <code>self</code> (let&rsquo;s call it <code>Measure::&lt;_, U&gt;</code>);</li>
<li>determine the type of result of the the call to <code>unify</code> (let&rsquo;s call it <code>Measure::&lt;_, V&gt;</code>);</li>
<li>using the equational laws defined earlier, check that <code>U ≡ V</code>;</li>
<li>if we cannot prove that <code>U ≡ V</code>, minimize the error message and display it;</li>
<li>if all instances were proven, accept the code, otherwise reject it.</li>
</ol></div>
<p class="component-content component">Indeed, <code>yaiouom-checker</code> is an implementation of a <em>refinement type system</em> for Rust: a type system that takes as input the result of a previous type system and introduces new verifications/guarantees. The unit of measure type system fits in roughly 200 lines of code, connected to <code>rustc</code> by about 200 more lines of code.</p>

<div class="component-content pagebody component">
  <h1 id="status-of-the-project" class="pagebody-header">
    Status of the project
  </h1>
</div><p class="component-content component">This project is very much a proof of concept. If I find time, I&rsquo;d like to eventually make it more robust, perhaps submit it as an extension of <code>clippy</code>.</p>
<p class="component-content component">In the meantime, if you&rsquo;re interested, <a href="https://github.com/Yoric/yaiouom">the code is here</a>!</p>
          </div><div class="component">
            <div class="component-content">
              <div class="article-copyright">
                <p class="content">
                  Copyright: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed" target="_blank">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a>
                </p>
                <p class="content">Author:  David Teller </p>
                <p class="content">Posted on:  January 17, 2020</p>
              </div>
            </div>
          </div></article>
      </section>
      
      <div id="gitalk-container"></div>
      GITALK ENABLED
      <script>
        const gitalk = new Gitalk({
          clientID: 'be349d0bd8338cd1aa1d',
          clientSecret: '6190d06de070bfa3ed050a29390a4ccd77ba032a',
          repo: 'yoric.github.io',    
          owner: 'Yoric',
          admin: ['Yoric'],
          id: '39f584e91ab32d1473b4f91b17cf29d1',  
          distractionFreeMode: false  
        })

        gitalk.render('gitalk-container')
      </script>
      
    </main>

  <script>
    var script = document.createElement("script");script.src = "https://yoric.github.io/js/initPost.js";
    document.head.appendChild(script);
  </script>

    
    <div class="footer-main ">
  <div class="content-body footer-wraper">
    <div class="footer-box">
      <div class="foot-nav">
        <div class="foot-nav-items">
          <div class="item">
            <div class="logo"></div>
            <div class="email">Email: <a href="mailto:D.O.MyLastName@gmail.com">D.O.MyLastName@gmail.com</a></div>
          </div>

          <div class="item community">
            <div class="item-title">Social Media</div>
            
              <a href="http://github.com/Yoric" target="_blank">github</a>
            
          </div>

          <div class="item resources">
            <div class="item-title">Related</div>
            
          </div>
        </div>
      </div>
      <div class="bottom">
        <div class="item copyright">
          &copy; 2024
          Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> & <a href="https://github.com/floyd-li/hugo-theme-itheme" target="_blank">iTheme</a>
        </div>
      </div>
    </div>
  </div>
</div>

  </body>
    
    

    
    
</html>
